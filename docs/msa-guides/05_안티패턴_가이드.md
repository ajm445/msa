# MSA 안티패턴 가이드

## 문서 정보

| 항목 | 내용 |
|------|------|
| 문서명 | MSA 안티패턴 가이드 |
| 버전 | 1.0 |
| 목적 | MSA 설계/구현 시 피해야 할 안티패턴 식별 및 해결 방안 제공 |

---

## 1. 안티패턴 개요

### 1.1 안티패턴이란?

**안티패턴(Anti-pattern)**은 자주 발생하지만 비효율적이거나 역효과를 내는 설계/구현 방식이다.

### 1.2 MSA 안티패턴 분류

| 분류 | 안티패턴 |
|------|---------|
| 아키텍처 | 분산 모놀리스, 나노서비스 |
| 데이터 | 공유 데이터베이스, 분산 모놀리스 DB |
| 통신 | 동기 통신 남용, 체이닝 |
| 조직 | 서비스-팀 불일치 |
| 운영 | 로깅/모니터링 미비 |

---

## 2. 분산 모놀리스 (Distributed Monolith)

### 2.1 정의

**분산 모놀리스**는 MSA의 형태를 갖추었지만 모놀리식의 단점을 그대로 가진 아키텍처이다.

### 2.2 증상

| 증상 | 설명 |
|------|------|
| 동시 배포 | 여러 서비스를 함께 배포해야 함 |
| 강한 의존성 | 서비스 변경 시 다른 서비스도 변경 필요 |
| 공유 라이브러리 | 핵심 로직이 공유 라이브러리에 있음 |
| 동기 체인 | 긴 동기 호출 체인 |
| 공유 DB | 여러 서비스가 같은 DB 사용 |

### 2.3 예시

**문제 상황**:
```
┌─────────┐    ┌─────────┐    ┌─────────┐
│Service A│───▶│Service B│───▶│Service C│
└────┬────┘    └────┬────┘    └────┬────┘
     │              │              │
     └──────────────┴──────────────┘
                    │
              ┌─────▼─────┐
              │ 공유 DB   │  ← 모든 서비스가
              │           │     같은 DB 사용
              └───────────┘
```

### 2.4 원인

- 모놀리스를 단순 분리만 함
- 도메인 경계 미정의
- 기술적 분리만 수행
- 팀 구조 변경 없음

### 2.5 해결 방안

**1. 도메인 경계 재정의**
- DDD 기반 서비스 재설계
- Bounded Context 명확히 정의

**2. 데이터 분리**
- Database per Service 적용
- 공유 DB → API 호출로 전환

**3. 비동기 통신 도입**
- 이벤트 기반 통신
- 메시지 큐 활용

**4. 공유 라이브러리 분리**
- 비즈니스 로직은 서비스 내부로
- 유틸리티만 공유

---

## 3. 공유 데이터베이스 (Shared Database)

### 3.1 정의

여러 마이크로서비스가 동일한 데이터베이스를 직접 접근하는 안티패턴이다.

### 3.2 문제점

| 문제 | 설명 |
|------|------|
| 스키마 결합 | 테이블 변경이 모든 서비스에 영향 |
| 독립 배포 불가 | DB 변경 시 관련 서비스 동시 배포 |
| 확장성 제한 | DB가 병목 |
| 장애 전파 | DB 장애가 전체 시스템에 영향 |
| 기술 종속 | 단일 DB 기술에 종속 |

### 3.3 예시

**안티패턴**:
```
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 주문    │  │ 재고    │  │ 배송    │
│ 서비스  │  │ 서비스  │  │ 서비스  │
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
     └────────────┼────────────┘
                  ▼
           ┌───────────┐
           │  공유 DB  │  ← 안티패턴
           └───────────┘
```

### 3.4 해결 방안

**패턴 적용**:
```
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 주문    │  │ 재고    │  │ 배송    │
│ 서비스  │  │ 서비스  │  │ 서비스  │
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
     ▼            ▼            ▼
┌─────────┐  ┌─────────┐  ┌─────────┐
│주문 DB  │  │재고 DB  │  │배송 DB  │
└─────────┘  └─────────┘  └─────────┘
```

**마이그레이션 단계**:
1. 서비스별 스키마 분리
2. 직접 접근 → API 호출 전환
3. 물리적 DB 분리
4. 이벤트 기반 데이터 동기화

---

## 4. 나노서비스 (Nanoservices)

### 4.1 정의

**나노서비스**는 지나치게 작게 분리된 서비스로, 관리 오버헤드가 가치를 초과하는 경우이다.

### 4.2 증상

| 증상 | 지표 |
|------|------|
| 코드량 | 서비스당 수백 줄 |
| 기능 | 단일 CRUD 또는 단일 함수 |
| 통신 | 단순 작업에 다중 서비스 호출 |
| 운영 | 서비스 수 > 개발자 수 |

### 4.3 문제점

- 네트워크 오버헤드 증가
- 분산 트랜잭션 복잡도
- 운영 복잡도 폭증
- 디버깅 어려움
- 인프라 비용 증가

### 4.4 예시

**안티패턴 - 과도한 분리**:
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   User      │───▶│   Email     │───▶│   Email     │
│ Validation  │    │ Validation  │    │   Sending   │
│  Service    │    │  Service    │    │   Service   │
└─────────────┘    └─────────────┘    └─────────────┘
         │
         ▼
┌─────────────┐    ┌─────────────┐
│   Password  │───▶│   Password  │
│ Validation  │    │   Hashing   │
│  Service    │    │   Service   │
└─────────────┘    └─────────────┘
```

**적절한 분리**:
```
┌─────────────────────────────────────┐
│           User Service              │
│  ┌─────────┐  ┌─────────┐          │
│  │Validate │  │ Hash    │          │
│  │         │  │ Password│          │
│  └─────────┘  └─────────┘          │
└─────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────┐
│         Notification Service        │
│  ┌─────────┐  ┌─────────┐          │
│  │ Email   │  │  SMS    │          │
│  └─────────┘  └─────────┘          │
└─────────────────────────────────────┘
```

### 4.5 적정 서비스 크기 기준

| 기준 | 권장 범위 |
|------|----------|
| 팀 크기 | 3-9명 (Two Pizza) |
| 재작성 시간 | 2-4주 |
| 코드 라인 | 1,000-50,000 |
| API 수 | 5-20개 |

---

## 5. 동기 통신 체인 (Synchronous Chain)

### 5.1 정의

서비스 간 긴 동기 호출 체인으로 인해 지연과 장애가 전파되는 안티패턴이다.

### 5.2 문제점

```
Client ──▶ A ──▶ B ──▶ C ──▶ D ──▶ E
           │     │     │     │     │
        100ms 100ms 100ms 100ms 100ms
           │
        총 지연: 500ms+
        장애 전파: E 실패 → 전체 실패
```

**문제**:
- 응답 시간 = 체인 전체 합
- 가용성 = 각 서비스 가용성의 곱
- 한 서비스 장애 → 전체 장애

**가용성 계산 예시**:
```
각 서비스 가용성 99.9%
5개 서비스 체인 = 0.999^5 = 99.5%
→ 월간 약 3.6시간 다운타임 증가
```

### 5.3 해결 방안

**1. 비동기 통신으로 전환**:
```
Client ──▶ A ──message──▶ B ──message──▶ C
           │
        즉시 응답
```

**2. 이벤트 기반 아키텍처**:
```
      ┌─────────────────────────────┐
      │        Event Bus            │
      └─────────────────────────────┘
        ▲           ▲           ▲
        │           │           │
   ┌────┴────┐ ┌────┴────┐ ┌────┴────┐
   │Service A│ │Service B│ │Service C│
   └─────────┘ └─────────┘ └─────────┘
```

**3. Saga 패턴 적용**

**4. 캐싱으로 호출 최소화**

---

## 6. 순환 의존성 (Circular Dependency)

### 6.1 정의

서비스 간 상호 의존으로 인해 순환 참조가 발생하는 안티패턴이다.

### 6.2 예시

**안티패턴**:
```
┌─────────┐      ┌─────────┐
│ Order   │─────▶│ Payment │
│ Service │◀─────│ Service │
└─────────┘      └─────────┘
      │
      └──────────────┐
                     ▼
              ┌─────────┐
              │Inventory│
              │ Service │
              └────┬────┘
                   │
                   ▼
              ┌─────────┐
              │ Order   │  ← 순환!
              │ Service │
              └─────────┘
```

### 6.3 문제점

- 배포 순서 의존성
- 장애 전파 복잡
- 테스트 어려움
- 버전 관리 복잡

### 6.4 해결 방안

**1. 의존성 역전 (이벤트 기반)**:
```
┌─────────┐                  ┌─────────┐
│ Order   │──OrderCreated──▶│ Payment │
│ Service │                  │ Service │
└─────────┘                  └─────────┘
     ▲                            │
     │                            │
     └───PaymentCompleted─────────┘
```

**2. 공통 서비스 추출**:
```
┌─────────┐     ┌─────────┐     ┌─────────┐
│ Order   │────▶│ Pricing │◀────│ Payment │
│ Service │     │ Service │     │ Service │
└─────────┘     └─────────┘     └─────────┘
```

**3. API Gateway에서 조합**

---

## 7. 부적절한 서비스 경계

### 7.1 기술 기반 분리 (잘못된 예)

**안티패턴 - 레이어별 분리**:
```
┌─────────────────────────────────────────┐
│              UI Service                  │
└─────────────────────────────────────────┘
                   │
┌─────────────────────────────────────────┐
│           Business Logic Service         │  ← 안티패턴
└─────────────────────────────────────────┘
                   │
┌─────────────────────────────────────────┐
│             Data Access Service          │
└─────────────────────────────────────────┘
```

### 7.2 올바른 분리 - 비즈니스 기능 기반

```
┌───────────┐  ┌───────────┐  ┌───────────┐
│   User    │  │   Order   │  │  Payment  │
│  Service  │  │  Service  │  │  Service  │
│ ┌───────┐ │  │ ┌───────┐ │  │ ┌───────┐ │
│ │  UI   │ │  │ │  UI   │ │  │ │  UI   │ │
│ │ Logic │ │  │ │ Logic │ │  │ │ Logic │ │
│ │  Data │ │  │ │  Data │ │  │ │  Data │ │
│ └───────┘ │  │ └───────┘ │  │ └───────┘ │
└───────────┘  └───────────┘  └───────────┘
```

### 7.3 분리 기준 체크리스트

| 질문 | Yes → 분리 | No → 유지 |
|------|-----------|----------|
| 독립적 비즈니스 가치? | ✓ | - |
| 독립적 배포 필요? | ✓ | - |
| 다른 확장 요구? | ✓ | - |
| 다른 팀 소유? | ✓ | - |
| 공유 데이터 많음? | - | ✓ |

---

## 8. 분산 모놀리스 DB

### 8.1 정의

서비스는 분리했지만 데이터는 논리적으로 결합된 상태를 유지하는 안티패턴이다.

### 8.2 증상

- 여러 서비스가 같은 테이블 참조
- 외래 키로 서비스 간 연결
- JOIN 쿼리가 서비스 경계를 넘음
- 스키마 변경 시 여러 서비스 수정 필요

### 8.3 예시

**안티패턴**:
```sql
-- 주문 서비스에서 사용자 테이블 직접 JOIN
SELECT o.*, u.name, u.email
FROM orders o
JOIN users u ON o.user_id = u.id  -- 다른 서비스 데이터!
WHERE o.id = ?
```

### 8.4 해결 방안

**1. 데이터 복제**:
```
User Service              Order Service
┌─────────────┐          ┌─────────────┐
│   users     │  Event   │ user_cache  │
│  (원본)     │────────▶│  (복제본)   │
└─────────────┘          └─────────────┘
```

**2. API 호출**:
```javascript
// 주문 서비스
async function getOrderDetails(orderId) {
  const order = await orderRepository.findById(orderId);
  const user = await userServiceClient.getUser(order.userId);

  return { ...order, user };
}
```

---

## 9. 로깅/모니터링 미비

### 9.1 문제점

분산 시스템에서 통합 로깅/모니터링 없이는:
- 장애 원인 추적 불가
- 성능 병목 파악 어려움
- 요청 흐름 추적 불가
- 장애 대응 지연

### 9.2 필수 구현 사항

| 항목 | 목적 | 도구 |
|------|------|------|
| 중앙 로깅 | 로그 집계/검색 | ELK, Loki |
| 분산 추적 | 요청 흐름 추적 | Jaeger, Zipkin |
| 메트릭 | 성능 모니터링 | Prometheus, Grafana |
| 알림 | 장애 감지/알림 | PagerDuty, AlertManager |

### 9.3 분산 추적 구현

**Correlation ID 전파**:
```javascript
// 요청 시작점에서 ID 생성
const correlationId = req.headers['x-correlation-id'] || uuid();

// 모든 하위 호출에 전파
await axios.get('http://service-b/api', {
  headers: { 'x-correlation-id': correlationId }
});

// 로그에 포함
logger.info('Processing request', { correlationId, action: 'start' });
```

---

## 10. 안티패턴 감지 체크리스트

### 10.1 아키텍처 진단

| 질문 | Yes = 안티패턴 위험 |
|------|-------------------|
| 여러 서비스를 함께 배포해야 하는가? | □ |
| 서비스 변경 시 다른 서비스도 수정해야 하는가? | □ |
| 서비스 간 직접 DB 접근이 있는가? | □ |
| 긴 동기 호출 체인이 있는가? | □ |
| 서비스 간 순환 의존성이 있는가? | □ |
| 서비스당 코드가 수백 줄 이하인가? | □ |
| 서비스 수가 팀원 수보다 많은가? | □ |

### 10.2 데이터 진단

| 질문 | Yes = 안티패턴 위험 |
|------|-------------------|
| 여러 서비스가 같은 테이블을 사용하는가? | □ |
| 서비스 간 외래 키 관계가 있는가? | □ |
| 크로스 서비스 JOIN이 있는가? | □ |
| DB 스키마 변경이 여러 서비스에 영향을 주는가? | □ |

### 10.3 운영 진단

| 질문 | Yes = 안티패턴 위험 |
|------|-------------------|
| 통합 로깅 시스템이 없는가? | □ |
| 분산 추적이 불가능한가? | □ |
| 장애 원인 파악에 오래 걸리는가? | □ |
| 서비스별 메트릭이 없는가? | □ |

---

## 11. 안티패턴 해결 우선순위

### 11.1 우선순위 매트릭스

| 안티패턴 | 영향도 | 해결 난이도 | 우선순위 |
|----------|--------|------------|---------|
| 공유 DB | 높음 | 높음 | 1 |
| 분산 모놀리스 | 높음 | 높음 | 1 |
| 동기 체인 | 높음 | 중간 | 2 |
| 순환 의존성 | 중간 | 중간 | 2 |
| 모니터링 미비 | 높음 | 낮음 | 2 |
| 나노서비스 | 중간 | 중간 | 3 |
| 부적절한 경계 | 중간 | 높음 | 3 |

### 11.2 단계별 해결 전략

**1단계 - 가시성 확보**:
- 로깅/모니터링 구축
- 의존성 맵 작성
- 현황 파악

**2단계 - 빠른 승리**:
- 순환 의존성 제거
- 동기 체인 개선

**3단계 - 근본 해결**:
- 서비스 경계 재정의
- 데이터 분리
- 비동기 전환

---

## 12. 참고 자료

### 12.1 핵심 용어

| 용어 | 설명 |
|------|------|
| Distributed Monolith | MSA 형태지만 모놀리식처럼 동작 |
| Nanoservice | 지나치게 작은 서비스 |
| Shared Database | 여러 서비스가 공유하는 DB |
| Circular Dependency | 서비스 간 순환 참조 |
| Synchronous Chain | 긴 동기 호출 체인 |

### 12.2 진단 도구

| 도구 | 용도 |
|------|------|
| Jaeger | 분산 추적, 의존성 분석 |
| Kiali | 서비스 메시 시각화 |
| SonarQube | 코드 품질, 의존성 분석 |

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| 1.0 | 2025-01-07 | 최초 작성 |
