# MSA 설계 패턴 가이드

## 문서 정보

| 항목 | 내용 |
|------|------|
| 문서명 | MSA 설계 패턴 가이드 |
| 버전 | 1.0 |
| 목적 | 마이크로서비스 아키텍처 설계 패턴 및 적용 가이드 |

---

## 1. 설계 패턴 개요

### 1.1 패턴 분류

| 분류 | 패턴 | 목적 |
|------|------|------|
| 분해 패턴 | 비즈니스 기능별, 서브도메인별 | 서비스 분리 |
| 통신 패턴 | API Gateway, BFF | 클라이언트 통신 |
| 데이터 패턴 | Saga, CQRS, Event Sourcing | 데이터 관리 |
| 안정성 패턴 | Circuit Breaker, Bulkhead, Retry | 장애 대응 |
| 배포 패턴 | Blue-Green, Canary | 무중단 배포 |

### 1.2 패턴 선택 기준

- 비즈니스 요구사항
- 시스템 복잡도
- 팀 역량
- 운영 환경

---

## 2. API Gateway 패턴

### 2.1 개념

**API Gateway**는 모든 클라이언트 요청의 단일 진입점으로, 요청을 적절한 서비스로 라우팅한다.

```
┌─────────┐    ┌─────────────────┐    ┌─────────────┐
│ Client  │───▶│   API Gateway   │───▶│  Service A  │
└─────────┘    │                 │    └─────────────┘
               │  - 라우팅        │    ┌─────────────┐
               │  - 인증/인가     │───▶│  Service B  │
               │  - Rate Limit   │    └─────────────┘
               │  - 로깅         │    ┌─────────────┐
               └─────────────────┘───▶│  Service C  │
                                      └─────────────┘
```

### 2.2 주요 기능

| 기능 | 설명 |
|------|------|
| 요청 라우팅 | URL 패턴 기반 서비스 라우팅 |
| 인증/인가 | JWT 검증, API 키 관리 |
| Rate Limiting | 요청 횟수 제한 |
| 로드 밸런싱 | 서비스 인스턴스 간 부하 분산 |
| 캐싱 | 응답 캐싱으로 성능 향상 |
| 요청/응답 변환 | 프로토콜 변환, 데이터 포맷 변환 |
| 로깅/모니터링 | 요청 추적, 메트릭 수집 |

### 2.3 구현 방식

**Edge Gateway**:
- 외부 클라이언트 전용
- 보안 기능 중심
- 예: Kong, AWS API Gateway

**Internal Gateway**:
- 서비스 간 내부 통신
- 서비스 디스커버리 연동
- 예: Zuul, Spring Cloud Gateway

### 2.4 주요 도구

| 도구 | 특징 | 적합 환경 |
|------|------|----------|
| Kong | 플러그인 생태계, Lua 확장 | 범용 |
| AWS API Gateway | 관리형, Lambda 연동 | AWS |
| Nginx | 고성능, 경량 | 온프레미스 |
| Spring Cloud Gateway | Java 생태계, 반응형 | Spring 기반 |
| Envoy | 서비스 메시, gRPC 지원 | Kubernetes |

---

## 3. BFF (Backend For Frontend) 패턴

### 3.1 개념

**BFF**는 각 클라이언트 유형별로 전용 백엔드를 제공하는 패턴이다.

```
┌─────────┐    ┌───────────┐    ┌─────────────┐
│  Web    │───▶│  Web BFF  │───▶│             │
└─────────┘    └───────────┘    │             │
                                │   Backend   │
┌─────────┐    ┌───────────┐    │  Services   │
│ Mobile  │───▶│Mobile BFF │───▶│             │
└─────────┘    └───────────┘    │             │
                                │             │
┌─────────┐    ┌───────────┐    │             │
│  IoT    │───▶│  IoT BFF  │───▶│             │
└─────────┘    └───────────┘    └─────────────┘
```

### 3.2 장점

- 클라이언트별 최적화된 API
- 클라이언트 요구사항 변경에 독립적
- 프론트엔드 팀의 자율성

### 3.3 적용 시점

**BFF가 필요한 경우**:
- 클라이언트별 요구사항이 다름
- 모바일/웹/IoT 등 다양한 클라이언트
- 프론트엔드 팀이 API 형태를 결정해야 함

**BFF가 불필요한 경우**:
- 단일 클라이언트 유형
- 간단한 API 요구사항
- 소규모 팀

---

## 4. Circuit Breaker 패턴

### 4.1 개념

**Circuit Breaker**는 연속적인 실패 시 호출을 차단하여 장애 전파를 방지하는 패턴이다.

### 4.2 상태 전이

```
                  성공
            ┌─────────────┐
            │             │
            ▼             │
     ┌──────────┐    ┌────┴─────┐
     │  Closed  │───▶│   Open   │
     └────┬─────┘    └────┬─────┘
          │               │
   임계치 초과          타임아웃
          │               │
          │         ┌─────▼─────┐
          │         │ Half-Open │
          │         └─────┬─────┘
          │               │
          └───────────────┘
               성공 시 Closed로
               실패 시 Open으로
```

### 4.3 상태별 동작

| 상태 | 조건 | 동작 |
|------|------|------|
| **Closed** | 정상 상태 | 요청 통과, 실패 카운트 |
| **Open** | 실패율 임계치 초과 | 요청 즉시 실패 (Fallback) |
| **Half-Open** | Open 후 대기 시간 경과 | 일부 요청 시도, 복구 확인 |

### 4.4 설정 파라미터

| 파라미터 | 설명 | 예시 값 |
|----------|------|--------|
| failureThreshold | 실패 임계치 | 50% |
| successThreshold | 복구 판단 성공 횟수 | 5회 |
| timeout | Open 상태 유지 시간 | 30초 |
| windowSize | 실패율 계산 윈도우 | 10회 |

### 4.5 구현 예시

```javascript
class CircuitBreaker {
  constructor(options) {
    this.failureThreshold = options.failureThreshold || 5;
    this.resetTimeout = options.resetTimeout || 30000;
    this.state = 'CLOSED';
    this.failureCount = 0;
    this.lastFailureTime = null;
  }

  async call(fn) {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime >= this.resetTimeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit is OPEN');
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  onSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  onFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}
```

### 4.6 Fallback 전략

| 전략 | 설명 | 예시 |
|------|------|------|
| 기본값 반환 | 하드코딩된 기본 응답 | 빈 목록, 기본 설정 |
| 캐시 반환 | 이전에 캐시된 데이터 | 마지막 성공 응답 |
| 대체 서비스 | 다른 서비스 호출 | 백업 서버 |
| 에러 응답 | 명확한 에러 메시지 | 서비스 일시 불가 |

---

## 5. Bulkhead 패턴

### 5.1 개념

**Bulkhead**는 시스템을 격리된 구획으로 분리하여 한 부분의 장애가 전체에 영향을 주지 않도록 한다.

```
┌─────────────────────────────────────────────┐
│                 Application                  │
│  ┌───────────┐  ┌───────────┐  ┌───────────┐│
│  │ Pool A    │  │ Pool B    │  │ Pool C    ││
│  │ (Service A)│ │ (Service B)│ │ (Service C)││
│  │           │  │           │  │           ││
│  │ 10 threads│  │ 10 threads│  │ 10 threads││
│  └───────────┘  └───────────┘  └───────────┘│
└─────────────────────────────────────────────┘
```

### 5.2 구현 방식

| 방식 | 설명 | 사용 사례 |
|------|------|----------|
| 스레드 풀 | 서비스별 독립 스레드 풀 | 동기 호출 |
| 세마포어 | 동시 실행 수 제한 | 비동기 호출 |
| 연결 풀 | DB/HTTP 연결 수 제한 | 외부 리소스 |

### 5.3 장점

- 장애 격리
- 리소스 고갈 방지
- 서비스별 독립적 스케일링

---

## 6. Retry 패턴

### 6.1 개념

일시적 장애 발생 시 자동으로 재시도하는 패턴이다.

### 6.2 재시도 전략

| 전략 | 설명 | 적합 상황 |
|------|------|----------|
| 즉시 재시도 | 지연 없이 재시도 | 순간적 오류 |
| 고정 간격 | 일정 간격으로 재시도 | 일반적 오류 |
| 지수 백오프 | 간격을 지수적으로 증가 | 부하 관련 오류 |
| 지터 추가 | 랜덤 지연 추가 | 동시 재시도 방지 |

### 6.3 지수 백오프 + 지터

```javascript
function calculateDelay(attempt, baseDelay = 1000, maxDelay = 30000) {
  // 지수 백오프: 1초, 2초, 4초, 8초, ...
  const exponentialDelay = baseDelay * Math.pow(2, attempt);

  // 최대 지연 제한
  const boundedDelay = Math.min(exponentialDelay, maxDelay);

  // 지터 추가 (0~100% 랜덤)
  const jitter = boundedDelay * Math.random();

  return boundedDelay + jitter;
}
```

### 6.4 재시도 조건

**재시도 해야 하는 경우**:
- 네트워크 타임아웃
- 503 Service Unavailable
- 429 Too Many Requests
- 연결 실패

**재시도하면 안 되는 경우**:
- 400 Bad Request
- 401 Unauthorized
- 404 Not Found
- 비즈니스 로직 오류

---

## 7. Timeout 패턴

### 7.1 타임아웃 유형

| 유형 | 설명 | 설정 위치 |
|------|------|----------|
| 연결 타임아웃 | 연결 수립 대기 시간 | HTTP Client |
| 읽기 타임아웃 | 응답 대기 시간 | HTTP Client |
| 요청 타임아웃 | 전체 요청 처리 시간 | 서비스 레벨 |

### 7.2 타임아웃 설정 가이드

```
Client ──▶ Gateway ──▶ Service A ──▶ Service B
  │          │            │            │
  │          │            │          500ms
  │          │          1000ms          │
  │        2000ms          │            │
  3000ms     │            │            │
```

**원칙**: 상위 레벨 타임아웃 > 하위 레벨 타임아웃 합

### 7.3 타임아웃 처리

```javascript
async function callWithTimeout(fn, timeoutMs) {
  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Timeout')), timeoutMs)
  );

  return Promise.race([fn(), timeoutPromise]);
}

// 사용 예시
try {
  const result = await callWithTimeout(
    () => fetch('http://service-a/api'),
    5000 // 5초 타임아웃
  );
} catch (error) {
  if (error.message === 'Timeout') {
    // 타임아웃 처리 (Fallback 등)
  }
}
```

---

## 8. Saga 패턴

### 8.1 개념

**Saga**는 분산 트랜잭션을 일련의 로컬 트랜잭션으로 분해하고, 실패 시 보상 트랜잭션을 실행하는 패턴이다.

### 8.2 Choreography vs Orchestration

| 항목 | Choreography | Orchestration |
|------|--------------|---------------|
| 조정 방식 | 분산 (이벤트) | 중앙 (조정자) |
| 결합도 | 낮음 | 중간 |
| 흐름 파악 | 어려움 | 용이 |
| 단일 장애점 | 없음 | 조정자 |
| 적합 상황 | 단순 Saga | 복잡 Saga |

### 8.3 Orchestration Saga 예시

**주문 처리 Saga**:

```
┌─────────────────────────────────────────────────────────┐
│                 Order Saga Orchestrator                  │
└─────────────────────────────────────────────────────────┘
     │           │           │           │           │
     ▼           ▼           ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│1. 주문  │ │2. 재고  │ │3. 결제  │ │4. 배송  │ │5. 알림  │
│  생성   │ │  예약   │ │  처리   │ │  예약   │ │  발송   │
└─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘
     │           │           │           │
     ▼           ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│1. 주문  │ │2. 재고  │ │3. 결제  │ │4. 배송  │  ← 보상
│  취소   │ │  복구   │ │  취소   │ │  취소   │    트랜잭션
└─────────┘ └─────────┘ └─────────┘ └─────────┘
```

### 8.4 상태 머신 기반 구현

```javascript
const orderSaga = {
  initial: 'PENDING',
  states: {
    PENDING: {
      on: { CREATE_ORDER: 'ORDER_CREATED' }
    },
    ORDER_CREATED: {
      on: {
        RESERVE_STOCK_SUCCESS: 'STOCK_RESERVED',
        RESERVE_STOCK_FAILURE: 'CANCELLING_ORDER'
      }
    },
    STOCK_RESERVED: {
      on: {
        PROCESS_PAYMENT_SUCCESS: 'PAYMENT_COMPLETED',
        PROCESS_PAYMENT_FAILURE: 'RELEASING_STOCK'
      }
    },
    RELEASING_STOCK: {
      on: { STOCK_RELEASED: 'CANCELLING_ORDER' }
    },
    CANCELLING_ORDER: {
      on: { ORDER_CANCELLED: 'FAILED' }
    },
    PAYMENT_COMPLETED: {
      on: { SCHEDULE_SHIPPING: 'COMPLETED' }
    },
    COMPLETED: { type: 'final' },
    FAILED: { type: 'final' }
  }
};
```

---

## 9. CQRS 패턴

### 9.1 개념

**CQRS (Command Query Responsibility Segregation)**는 명령(쓰기)과 조회(읽기) 책임을 분리하는 패턴이다.

### 9.2 구조

```
┌───────────────────────────────────────────────────────┐
│                       Client                          │
└───────────────────────────────────────────────────────┘
           │                              │
           ▼                              ▼
    ┌─────────────┐                ┌─────────────┐
    │   Command   │                │    Query    │
    │   Service   │                │   Service   │
    └──────┬──────┘                └──────┬──────┘
           │                              │
           ▼                              ▼
    ┌─────────────┐                ┌─────────────┐
    │   Write     │   이벤트       │    Read     │
    │   Model     │───────────────▶│   Model     │
    └──────┬──────┘                └──────┬──────┘
           │                              │
           ▼                              ▼
    ┌─────────────┐                ┌─────────────┐
    │  Write DB   │                │  Read DB    │
    │ (정규화)    │                │ (비정규화)  │
    └─────────────┘                └─────────────┘
```

### 9.3 장점과 단점

**장점**:
- 읽기/쓰기 독립적 최적화
- 높은 조회 성능
- 복잡한 도메인 로직 분리

**단점**:
- 시스템 복잡도 증가
- 데이터 동기화 지연 (최종 일관성)
- 개발/운영 비용 증가

### 9.4 적용 시점

**CQRS가 적합한 경우**:
- 읽기/쓰기 비율이 크게 다름
- 복잡한 조회 요구사항
- 이벤트 소싱과 함께 사용

**CQRS가 부적합한 경우**:
- 단순 CRUD 애플리케이션
- 강한 일관성 필수
- 소규모 시스템

---

## 10. Event Sourcing 패턴

### 10.1 개념

**Event Sourcing**은 상태 변경을 이벤트로 저장하고, 이벤트를 재생하여 현재 상태를 구성하는 패턴이다.

### 10.2 기존 방식 vs Event Sourcing

**기존 방식 (State-based)**:
```
┌─────────────────────────────────┐
│ Account                         │
├─────────────────────────────────┤
│ id: 1                           │
│ balance: 1000 ◀── 현재 상태만   │
│ updated_at: 2025-01-07          │
└─────────────────────────────────┘
```

**Event Sourcing**:
```
┌────────────────────────────────────────────┐
│ Account Events                              │
├────────────────────────────────────────────┤
│ 1. AccountCreated  { id: 1, balance: 0 }   │
│ 2. MoneyDeposited  { amount: 500 }         │
│ 3. MoneyDeposited  { amount: 700 }         │
│ 4. MoneyWithdrawn  { amount: 200 }         │
│    ────────────────────────                │
│    현재 잔액: 0 + 500 + 700 - 200 = 1000   │
└────────────────────────────────────────────┘
```

### 10.3 장점

- 완전한 감사 로그
- 시간 여행 (특정 시점 상태 복원)
- 이벤트 재생으로 버그 재현
- 새로운 뷰/프로젝션 생성 용이

### 10.4 단점

- 구현 복잡도 높음
- 이벤트 스키마 진화 어려움
- 저장 공간 증가
- 조회 성능 (스냅샷 필요)

### 10.5 스냅샷

성능을 위해 주기적으로 현재 상태를 스냅샷으로 저장한다.

```
이벤트 1 → 이벤트 2 → ... → 이벤트 100 → [스냅샷] → 이벤트 101 → ...
                                              │
                                    마지막 스냅샷부터 재생
```

---

## 11. 패턴 조합 가이드

### 11.1 일반적인 패턴 조합

| 조합 | 목적 |
|------|------|
| API Gateway + BFF | 클라이언트별 최적화 |
| Circuit Breaker + Retry + Timeout | 복합 장애 대응 |
| Saga + Event Sourcing | 분산 트랜잭션 + 감사 |
| CQRS + Event Sourcing | 이벤트 기반 읽기 최적화 |

### 11.2 패턴 선택 매트릭스

| 요구사항 | 권장 패턴 |
|----------|----------|
| 외부 API 진입점 | API Gateway |
| 클라이언트별 API | BFF |
| 장애 전파 방지 | Circuit Breaker |
| 리소스 격리 | Bulkhead |
| 일시적 장애 대응 | Retry + Timeout |
| 분산 트랜잭션 | Saga |
| 읽기 성능 최적화 | CQRS |
| 감사 로그 | Event Sourcing |

---

## 12. 참고 자료

### 12.1 핵심 용어

| 용어 | 설명 |
|------|------|
| API Gateway | 클라이언트 요청의 단일 진입점 |
| BFF | Backend For Frontend, 클라이언트별 백엔드 |
| Circuit Breaker | 장애 전파 방지 패턴 |
| Bulkhead | 리소스 격리 패턴 |
| Saga | 분산 트랜잭션 관리 패턴 |
| CQRS | 명령/조회 책임 분리 |
| Event Sourcing | 이벤트 기반 상태 관리 |

### 12.2 주요 도구

| 패턴 | 도구 |
|------|------|
| API Gateway | Kong, AWS API Gateway, Nginx |
| Circuit Breaker | Resilience4j, Hystrix, Polly |
| Saga | Axon, Eventuate, Temporal |
| Event Sourcing | Axon, EventStoreDB |

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| 1.0 | 2025-01-07 | 최초 작성 |
