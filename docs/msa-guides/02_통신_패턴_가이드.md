# MSA 통신 패턴 가이드

## 문서 정보

| 항목 | 내용 |
|------|------|
| 문서명 | MSA 통신 패턴 가이드 |
| 버전 | 1.0 |
| 목적 | 마이크로서비스 간 통신 방식 선택 및 구현 가이드 |

---

## 1. 통신 패턴 개요

### 1.1 통신 방식 분류

| 구분 | 동기 (Synchronous) | 비동기 (Asynchronous) |
|------|-------------------|----------------------|
| 특징 | 요청 후 응답 대기 | 요청 후 즉시 반환 |
| 결합도 | 높음 | 낮음 |
| 응답 시간 | 즉시 | 지연 가능 |
| 장애 전파 | 전파됨 | 격리됨 |
| 구현 복잡도 | 낮음 | 높음 |

### 1.2 통신 스타일

```
┌────────────────────────────────────────────────────────┐
│                    통신 스타일                          │
├─────────────────────┬──────────────────────────────────┤
│       동기          │            비동기                 │
├──────────┬──────────┼──────────┬───────────────────────┤
│   REST   │   gRPC   │ 메시지큐  │    이벤트 기반        │
│   API    │          │ (P2P)    │    (Pub/Sub)         │
└──────────┴──────────┴──────────┴───────────────────────┘
```

---

## 2. 동기 통신: REST API

### 2.1 REST 개요

**REST(Representational State Transfer)**는 HTTP 프로토콜 기반의 리소스 중심 아키텍처 스타일이다.

**핵심 원칙**:
- 리소스 중심 설계 (URI로 리소스 식별)
- HTTP 메서드로 행위 표현
- 상태 비저장 (Stateless)
- 표준 미디어 타입 (JSON, XML)

### 2.2 HTTP 메서드와 CRUD

| 메서드 | 용도 | 멱등성 | 안전성 |
|--------|------|--------|--------|
| GET | 조회 | O | O |
| POST | 생성 | X | X |
| PUT | 전체 수정 | O | X |
| PATCH | 부분 수정 | X | X |
| DELETE | 삭제 | O | X |

### 2.3 RESTful API 설계 규칙

**URI 설계 원칙**:
```
# 좋은 예
GET    /api/users              # 사용자 목록
GET    /api/users/{id}         # 특정 사용자
POST   /api/users              # 사용자 생성
PUT    /api/users/{id}         # 사용자 수정
DELETE /api/users/{id}         # 사용자 삭제
GET    /api/users/{id}/orders  # 사용자의 주문 목록

# 나쁜 예
GET    /api/getUsers
POST   /api/createUser
GET    /api/user/delete/{id}
```

### 2.4 HTTP 상태 코드

| 코드 | 의미 | 사용 상황 |
|------|------|----------|
| 200 | OK | 성공적인 조회/수정 |
| 201 | Created | 리소스 생성 성공 |
| 204 | No Content | 성공, 응답 본문 없음 |
| 400 | Bad Request | 잘못된 요청 형식 |
| 401 | Unauthorized | 인증 필요 |
| 403 | Forbidden | 권한 없음 |
| 404 | Not Found | 리소스 없음 |
| 409 | Conflict | 충돌 (중복 등) |
| 500 | Internal Error | 서버 오류 |
| 503 | Service Unavailable | 서비스 불가 |

### 2.5 REST 장단점

**장점**:
- 표준 HTTP 사용으로 범용성 높음
- 브라우저에서 직접 테스트 가능
- 캐싱 용이
- 다양한 클라이언트 지원

**단점**:
- 오버페칭/언더페칭 문제
- 다중 호출 필요할 수 있음
- 실시간 통신 제한적

---

## 3. 동기 통신: gRPC

### 3.1 gRPC 개요

**gRPC**는 Google이 개발한 고성능 RPC(Remote Procedure Call) 프레임워크이다.

**특징**:
- Protocol Buffers 기반 직렬화
- HTTP/2 사용
- 양방향 스트리밍 지원
- 강타입 인터페이스 정의

### 3.2 Protocol Buffers

```protobuf
// user.proto
syntax = "proto3";

service UserService {
  rpc GetUser(GetUserRequest) returns (User);
  rpc ListUsers(ListUsersRequest) returns (stream User);
  rpc CreateUser(CreateUserRequest) returns (User);
}

message User {
  string id = 1;
  string name = 2;
  string email = 3;
}

message GetUserRequest {
  string id = 1;
}
```

### 3.3 gRPC 통신 유형

| 유형 | 설명 | 사용 사례 |
|------|------|----------|
| Unary | 단일 요청-응답 | 일반 API 호출 |
| Server Streaming | 서버가 스트림 응답 | 대용량 데이터 조회 |
| Client Streaming | 클라이언트가 스트림 전송 | 파일 업로드 |
| Bidirectional | 양방향 스트림 | 실시간 채팅 |

### 3.4 REST vs gRPC 비교

| 항목 | REST | gRPC |
|------|------|------|
| 프로토콜 | HTTP/1.1 | HTTP/2 |
| 페이로드 | JSON/XML | Protocol Buffers |
| 계약 정의 | OpenAPI (선택) | Proto 파일 (필수) |
| 브라우저 지원 | 직접 지원 | 프록시 필요 |
| 성능 | 보통 | 높음 |
| 스트리밍 | 제한적 | 네이티브 지원 |
| 코드 생성 | 선택 | 필수 |

### 3.5 gRPC 사용 시점

**gRPC가 적합한 경우**:
- 서비스 간 내부 통신
- 고성능/저지연 요구
- 스트리밍 필요
- 강타입 계약 필요

**REST가 적합한 경우**:
- 외부 API 제공
- 브라우저 직접 통신
- 단순한 CRUD 작업
- 범용성 우선

---

## 4. 비동기 통신: 메시지 큐

### 4.1 메시지 큐 개요

**메시지 큐**는 서비스 간 비동기 통신을 위한 중간 저장소이다.

**구성 요소**:
- **Producer**: 메시지 생성/전송
- **Queue**: 메시지 저장소
- **Consumer**: 메시지 수신/처리

### 4.2 메시지 큐 패턴

**Point-to-Point (P2P)**:
```
┌──────────┐    ┌─────────┐    ┌──────────┐
│ Producer │───▶│  Queue  │───▶│ Consumer │
└──────────┘    └─────────┘    └──────────┘
```
- 하나의 메시지는 하나의 소비자만 처리
- 작업 분배에 적합

**Competing Consumers**:
```
┌──────────┐    ┌─────────┐    ┌──────────┐
│ Producer │───▶│  Queue  │───▶│Consumer 1│
└──────────┘    │         │    └──────────┘
                │         │    ┌──────────┐
                │         │───▶│Consumer 2│
                └─────────┘    └──────────┘
```
- 여러 소비자가 경쟁하여 처리
- 부하 분산에 적합

### 4.3 메시지 브로커 비교

| 항목 | RabbitMQ | Apache Kafka | AWS SQS |
|------|----------|--------------|---------|
| 유형 | 메시지 브로커 | 이벤트 스트리밍 | 관리형 큐 |
| 순서 보장 | 큐 내 보장 | 파티션 내 보장 | 제한적 |
| 메시지 보존 | 소비 후 삭제 | 설정 기간 보존 | 소비 후 삭제 |
| 처리량 | 중간 | 매우 높음 | 높음 |
| 복잡도 | 중간 | 높음 | 낮음 |
| 적합 사례 | 작업 큐 | 이벤트 소싱 | 단순 큐 |

### 4.4 메시지 전달 보장

| 보장 수준 | 설명 | 트레이드오프 |
|----------|------|-------------|
| At-most-once | 최대 1회 전달 | 메시지 손실 가능 |
| At-least-once | 최소 1회 전달 | 중복 가능 |
| Exactly-once | 정확히 1회 전달 | 구현 복잡, 성능 저하 |

**멱등성 처리**:
```javascript
// 중복 메시지 처리를 위한 멱등성 키
async function processOrder(message) {
  const idempotencyKey = message.headers['idempotency-key'];

  // 이미 처리된 메시지인지 확인
  if (await isProcessed(idempotencyKey)) {
    return; // 중복 메시지 무시
  }

  // 비즈니스 로직 처리
  await createOrder(message.body);

  // 처리 완료 기록
  await markAsProcessed(idempotencyKey);
}
```

---

## 5. 비동기 통신: 이벤트 기반

### 5.1 이벤트 기반 아키텍처

**Event-Driven Architecture**는 이벤트의 발행과 구독을 통해 서비스 간 통신하는 패턴이다.

**구성 요소**:
- **Event**: 시스템에서 발생한 사실
- **Publisher**: 이벤트 발행자
- **Subscriber**: 이벤트 구독자
- **Event Channel**: 이벤트 전달 채널

### 5.2 Pub/Sub 패턴

```
                    ┌────────────┐
                    │ Subscriber │
                    │     A      │
                    └─────▲──────┘
                          │
┌───────────┐    ┌────────┴────────┐    ┌────────────┐
│ Publisher │───▶│  Event Channel  │───▶│ Subscriber │
└───────────┘    │   (Topic)       │    │     B      │
                 └────────┬────────┘    └────────────┘
                          │
                    ┌─────▼──────┐
                    │ Subscriber │
                    │     C      │
                    └────────────┘
```

**특징**:
- Publisher는 Subscriber를 알 필요 없음
- 느슨한 결합 (Loose Coupling)
- 다대다 통신 가능
- 새 구독자 추가 용이

### 5.3 이벤트 유형

| 유형 | 설명 | 예시 |
|------|------|------|
| Domain Event | 비즈니스 의미가 있는 사건 | OrderCreated, PaymentCompleted |
| Integration Event | 서비스 간 통신용 이벤트 | UserRegisteredEvent |
| Notification Event | 알림 목적의 이벤트 | EmailSent, PushNotificationSent |

### 5.4 이벤트 설계 원칙

**이벤트 명명**:
- 과거형 사용 (OrderCreated, PaymentFailed)
- 도메인 용어 사용
- 구체적이고 명확하게

**이벤트 구조**:
```json
{
  "eventId": "evt_123456",
  "eventType": "OrderCreated",
  "timestamp": "2025-01-07T12:00:00Z",
  "aggregateId": "order_789",
  "aggregateType": "Order",
  "payload": {
    "orderId": "order_789",
    "customerId": "cust_456",
    "items": [...],
    "totalAmount": 50000
  },
  "metadata": {
    "correlationId": "corr_111",
    "userId": "user_222"
  }
}
```

### 5.5 이벤트 기반 장단점

**장점**:
- 서비스 간 결합도 최소화
- 확장성 우수
- 장애 격리
- 시스템 유연성

**단점**:
- 디버깅 어려움
- 이벤트 순서 보장 복잡
- 최종 일관성 (Eventual Consistency)
- 복잡한 흐름 추적

---

## 6. 통신 방식 선택 가이드

### 6.1 선택 기준 매트릭스

| 상황 | 권장 방식 | 이유 |
|------|----------|------|
| 즉시 응답 필요 | REST/gRPC | 동기 처리 필수 |
| 장시간 처리 작업 | 메시지 큐 | 타임아웃 방지 |
| 여러 서비스 알림 | 이벤트 (Pub/Sub) | 다대다 통신 |
| 고성능 내부 통신 | gRPC | 바이너리 프로토콜 |
| 외부 API 제공 | REST | 범용성 |
| 순서 보장 필요 | Kafka | 파티션 순서 보장 |
| 작업 분배 | 메시지 큐 | 경쟁 소비자 |

### 6.2 의사결정 플로우차트

```
시작
  │
  ▼
즉시 응답 필요?
  │
  ├─ Yes ─▶ 내부 통신?
  │            │
  │            ├─ Yes ─▶ 고성능 필요? ─┬─ Yes ─▶ gRPC
  │            │                       └─ No ──▶ REST
  │            │
  │            └─ No ──▶ REST API
  │
  └─ No ──▶ 다수 소비자?
              │
              ├─ Yes ─▶ Pub/Sub (이벤트)
              │
              └─ No ──▶ 순서 중요?
                          │
                          ├─ Yes ─▶ Kafka
                          │
                          └─ No ──▶ 메시지 큐
```

---

## 7. API 버저닝 전략

### 7.1 버저닝 방식

| 방식 | 예시 | 장점 | 단점 |
|------|------|------|------|
| URI Path | /api/v1/users | 명확함 | URI 변경 |
| Query Param | /api/users?v=1 | 선택적 | 캐싱 어려움 |
| Header | X-API-Version: 1 | URI 깔끔 | 테스트 어려움 |
| Content-Type | application/vnd.api.v1+json | 표준 준수 | 복잡함 |

### 7.2 버전 호환성

**하위 호환성 유지 원칙**:
- 필드 추가는 허용
- 필드 삭제/이름 변경 금지
- 필수 필드를 선택 필드로 변경 가능
- 기존 API 동작 변경 금지

**비호환 변경 시**:
1. 새 버전 API 출시
2. 구 버전 Deprecated 공지
3. 마이그레이션 기간 제공
4. 구 버전 종료

---

## 8. 서비스 간 계약 (Contract)

### 8.1 Consumer-Driven Contract

소비자(Consumer)가 기대하는 계약을 정의하고, 제공자(Provider)가 이를 충족하는지 검증하는 패턴.

**프로세스**:
1. Consumer가 계약 정의
2. Provider가 계약 기반 테스트
3. CI/CD에서 계약 검증
4. 계약 위반 시 배포 차단

### 8.2 계약 테스트 도구

| 도구 | 언어 | 특징 |
|------|------|------|
| Pact | 다중 언어 | Consumer-Driven |
| Spring Cloud Contract | Java | Spring 생태계 |
| Dredd | 다중 언어 | OpenAPI 기반 |

### 8.3 OpenAPI (Swagger) 명세

```yaml
openapi: 3.0.0
info:
  title: User Service API
  version: 1.0.0

paths:
  /users/{id}:
    get:
      summary: 사용자 조회
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: 성공
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          description: 사용자 없음

components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        email:
          type: string
          format: email
```

---

## 9. 통신 체크리스트

### 9.1 설계 시 확인사항

| 항목 | 질문 | 확인 |
|------|------|------|
| 동기/비동기 | 즉시 응답이 필요한가? | □ |
| 결합도 | 강한 결합이 허용되는가? | □ |
| 장애 격리 | 장애 전파를 방지해야 하는가? | □ |
| 확장성 | 높은 처리량이 필요한가? | □ |
| 순서 보장 | 메시지 순서가 중요한가? | □ |

### 9.2 구현 시 확인사항

| 항목 | 질문 | 확인 |
|------|------|------|
| 타임아웃 | 적절한 타임아웃이 설정되었는가? | □ |
| 재시도 | 재시도 로직이 구현되었는가? | □ |
| 멱등성 | 중복 처리에 안전한가? | □ |
| 에러 처리 | 실패 시 처리가 정의되었는가? | □ |
| 로깅 | 요청/응답 로깅이 있는가? | □ |
| 추적 | 분산 추적이 가능한가? | □ |

---

## 10. 참고 자료

### 10.1 핵심 용어

| 용어 | 설명 |
|------|------|
| REST | Representational State Transfer, HTTP 기반 아키텍처 스타일 |
| gRPC | Google Remote Procedure Call, 고성능 RPC 프레임워크 |
| Protocol Buffers | 구조화된 데이터 직렬화 포맷 |
| Message Queue | 비동기 메시지 전달을 위한 저장소 |
| Pub/Sub | 발행-구독 패턴 |
| Event-Driven | 이벤트 기반 아키텍처 |
| Idempotency | 멱등성, 동일 연산의 반복 실행이 동일 결과 |

### 10.2 주요 도구

| 영역 | 도구 |
|------|------|
| API Gateway | Kong, AWS API Gateway, Nginx |
| Message Broker | Kafka, RabbitMQ, AWS SQS |
| API 문서화 | Swagger/OpenAPI, Redoc |
| 계약 테스트 | Pact, Spring Cloud Contract |
| 분산 추적 | Jaeger, Zipkin, AWS X-Ray |

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| 1.0 | 2025-01-07 | 최초 작성 |
