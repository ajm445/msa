# MSA 마이그레이션 가이드

## 문서 정보

| 항목 | 내용 |
|------|------|
| 문서명 | MSA 마이그레이션 가이드 |
| 버전 | 1.0 |
| 목적 | 모놀리식에서 MSA로의 점진적 마이그레이션 전략 제공 |

---

## 1. 마이그레이션 개요

### 1.1 마이그레이션 접근 방식

| 방식 | 설명 | 위험도 |
|------|------|--------|
| Big Bang | 전체 시스템 일괄 전환 | 높음 |
| 점진적 전환 | 단계별 서비스 분리 | 낮음 |
| 병행 운영 | 신/구 시스템 병행 | 중간 |

**권장**: 점진적 전환 (Strangler Fig 패턴)

### 1.2 마이그레이션 단계

```
┌─────────────────────────────────────────────────────────┐
│  1. 평가    2. 계획    3. 분리    4. 전환    5. 검증   │
│     │          │          │          │          │      │
│     ▼          ▼          ▼          ▼          ▼      │
│  현황 분석  로드맵    서비스 분리  트래픽 전환  안정화  │
│  도메인 분석 우선순위  데이터 분리  모니터링   최적화   │
└─────────────────────────────────────────────────────────┘
```

---

## 2. Strangler Fig 패턴

### 2.1 개념

**Strangler Fig**는 교살자 무화과나무에서 유래한 패턴으로, 새 시스템이 점진적으로 기존 시스템을 대체하는 방식이다.

### 2.2 동작 원리

**1단계 - 프록시 도입**:
```
┌──────────┐    ┌───────────┐    ┌────────────┐
│  Client  │───▶│   Proxy   │───▶│  Monolith  │
└──────────┘    │(API GW)   │    └────────────┘
                └───────────┘
```

**2단계 - 일부 기능 분리**:
```
┌──────────┐    ┌───────────┐    ┌────────────┐
│  Client  │───▶│   Proxy   │───▶│  Monolith  │
└──────────┘    │           │    └────────────┘
                │           │    ┌────────────┐
                │           │───▶│ New Service│
                └───────────┘    └────────────┘
```

**3단계 - 점진적 확장**:
```
┌──────────┐    ┌───────────┐    ┌────────────┐
│  Client  │───▶│   Proxy   │    │  Monolith  │ (축소)
└──────────┘    │           │    └────────────┘
                │           │    ┌────────────┐
                │           │───▶│ Service A  │
                │           │    └────────────┘
                │           │    ┌────────────┐
                │           │───▶│ Service B  │
                └───────────┘    └────────────┘
```

**4단계 - 완료**:
```
┌──────────┐    ┌───────────┐    ┌────────────┐
│  Client  │───▶│ API GW    │───▶│ Service A  │
└──────────┘    │           │    └────────────┘
                │           │    ┌────────────┐
                │           │───▶│ Service B  │
                │           │    └────────────┘
                │           │    ┌────────────┐
                │           │───▶│ Service C  │
                └───────────┘    └────────────┘
```

### 2.3 구현 방법

**라우팅 규칙 예시 (Nginx)**:
```nginx
upstream monolith {
    server monolith.internal:8080;
}

upstream user_service {
    server user-service.internal:8080;
}

server {
    # 새 서비스로 라우팅 (마이그레이션 완료)
    location /api/users {
        proxy_pass http://user_service;
    }

    # 기존 모놀리스로 라우팅 (마이그레이션 대기)
    location / {
        proxy_pass http://monolith;
    }
}
```

### 2.4 장점

- 위험 최소화
- 점진적 학습
- 롤백 용이
- 비즈니스 연속성 유지

---

## 3. 서비스 분리 순서 결정

### 3.1 분리 우선순위 평가 기준

| 기준 | 설명 | 가중치 |
|------|------|--------|
| 비즈니스 가치 | 분리로 인한 비즈니스 이점 | 높음 |
| 변경 빈도 | 자주 변경되는 영역 | 높음 |
| 기술 부채 | 리팩토링 필요성 | 중간 |
| 결합도 | 다른 모듈과의 의존성 | 중간 |
| 복잡도 | 분리 난이도 | 낮음 |

### 3.2 분리 후보 선정 매트릭스

```
                     높음
              ┌─────────────────┐
              │ ① 우선 분리    │ ② 계획 수립
     비즈니스 │    User Auth    │    Order
       가치   │    Payment      │    Inventory
              ├─────────────────┤
              │ ③ 나중에       │ ④ 유지
              │    Logging      │    Legacy
              │    Monitoring   │    Admin
              └─────────────────┘
              낮음       분리 용이성        높음
```

### 3.3 첫 번째 서비스 선정

**좋은 첫 번째 후보**:
- 다른 모듈과 의존성 낮음
- 명확한 비즈니스 경계
- 독립적 데이터
- 팀 역량 검증 가능

**예시**:
- 인증/인가 서비스
- 알림 서비스
- 파일 업로드 서비스

---

## 4. 데이터 마이그레이션

### 4.1 데이터 분리 전략

| 전략 | 설명 | 적합 상황 |
|------|------|----------|
| 동기화 후 분리 | 데이터 복제 → 검증 → 전환 | 대용량 |
| 실시간 분리 | CDC로 실시간 동기화 | 다운타임 불가 |
| 애플리케이션 레벨 | 앱에서 양쪽 DB 쓰기 | 단순 |

### 4.2 동기화 후 분리 방법

**1단계 - 초기 복제**:
```
┌─────────────┐    Dump/Restore    ┌─────────────┐
│  기존 DB    │───────────────────▶│  신규 DB    │
│ (전체 데이터)│                    │ (초기 복제) │
└─────────────┘                    └─────────────┘
```

**2단계 - 실시간 동기화**:
```
┌─────────────┐        CDC         ┌─────────────┐
│  기존 DB    │───────────────────▶│  신규 DB    │
│  (Primary)  │   (Debezium 등)    │ (Replica)   │
└─────────────┘                    └─────────────┘
```

**3단계 - 전환**:
```
┌─────────────┐                    ┌─────────────┐
│  기존 DB    │                    │  신규 DB    │
│ (읽기 전용) │                    │ (Primary)   │
└─────────────┘                    └─────────────┘
```

### 4.3 데이터 일관성 검증

```javascript
// 데이터 검증 스크립트 예시
async function verifyDataConsistency() {
  const sourceCount = await sourceDb.query('SELECT COUNT(*) FROM users');
  const targetCount = await targetDb.query('SELECT COUNT(*) FROM users');

  if (sourceCount !== targetCount) {
    console.error('Count mismatch!', { sourceCount, targetCount });
    return false;
  }

  // 샘플 데이터 비교
  const sampleIds = await sourceDb.query('SELECT id FROM users LIMIT 100');
  for (const { id } of sampleIds) {
    const source = await sourceDb.query('SELECT * FROM users WHERE id = ?', [id]);
    const target = await targetDb.query('SELECT * FROM users WHERE id = ?', [id]);

    if (!deepEqual(source, target)) {
      console.error('Data mismatch!', { id, source, target });
      return false;
    }
  }

  return true;
}
```

### 4.4 참조 데이터 처리

**공유 참조 데이터 처리 옵션**:

| 옵션 | 설명 | 적합 상황 |
|------|------|----------|
| 복제 | 각 서비스에 복사본 유지 | 자주 조회, 드물게 변경 |
| API 조회 | 원본 서비스에 API 요청 | 항상 최신 필요 |
| 이벤트 동기화 | 변경 이벤트로 동기화 | 준실시간 |

---

## 5. 코드 분리 전략

### 5.1 모듈 추출 단계

**1단계 - 경계 식별**:
```
┌─────────────────────────────────────────┐
│              Monolith                    │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │ Module A│  │ Module B│  │ Module C│ │
│  │ ◀───────┼──┼────────▶│  │         │ │
│  └────┬────┘  └────┬────┘  └────┬────┘ │
│       └────────────┴────────────┘      │
│                 공유 DB                 │
└─────────────────────────────────────────┘
```

**2단계 - 인터페이스 정의**:
```java
// 기존: 직접 메서드 호출
orderService.createOrder(userId, items);

// 변경: 인터페이스 기반
public interface OrderService {
    Order createOrder(String userId, List<Item> items);
}
```

**3단계 - 의존성 역전**:
```java
// 인터페이스 구현 - 로컬 (현재)
@Service
class LocalOrderService implements OrderService {
    public Order createOrder(...) { /* 로컬 로직 */ }
}

// 인터페이스 구현 - 원격 (마이그레이션 후)
@Service
class RemoteOrderService implements OrderService {
    public Order createOrder(...) {
        return httpClient.post("/api/orders", ...);
    }
}
```

### 5.2 Feature Toggle 활용

```java
@Service
class OrderServiceRouter implements OrderService {
    private final LocalOrderService localService;
    private final RemoteOrderService remoteService;
    private final FeatureToggle featureToggle;

    public Order createOrder(String userId, List<Item> items) {
        if (featureToggle.isEnabled("use-order-microservice")) {
            return remoteService.createOrder(userId, items);
        }
        return localService.createOrder(userId, items);
    }
}
```

### 5.3 공유 코드 처리

| 코드 유형 | 처리 방법 |
|----------|----------|
| 유틸리티 | 공용 라이브러리로 추출 |
| 도메인 모델 | 각 서비스에 복제 (분리) |
| API 계약 | 공용 스키마 정의 |
| 비즈니스 로직 | 적절한 서비스로 이동 |

---

## 6. 트래픽 전환 전략

### 6.1 전환 방식

| 방식 | 설명 | 위험도 | 롤백 |
|------|------|--------|------|
| 일괄 전환 | 즉시 100% 전환 | 높음 | 어려움 |
| Canary | 점진적 비율 증가 | 낮음 | 용이 |
| Blue-Green | 두 환경 전환 | 중간 | 용이 |
| Shadow | 복제 트래픽으로 테스트 | 낮음 | N/A |

### 6.2 Canary 배포

```
┌─────────────────────────────────────────────────────────┐
│                    Load Balancer                         │
└─────────────────────────────────────────────────────────┘
           │                              │
           │ 90%                          │ 10%
           ▼                              ▼
    ┌─────────────┐                ┌─────────────┐
    │  Monolith   │                │ New Service │
    │  (기존)     │                │  (Canary)   │
    └─────────────┘                └─────────────┘
```

**전환 단계**:
1. 1% → 5% → 10% → 25% → 50% → 100%
2. 각 단계에서 메트릭 모니터링
3. 문제 시 즉시 0%로 롤백

### 6.3 Shadow 트래픽

실제 트래픽을 복제하여 신규 서비스 테스트:

```
┌──────────┐    ┌───────────────┐    ┌─────────────┐
│  Client  │───▶│   Proxy       │───▶│  Monolith   │ (응답)
└──────────┘    │               │    └─────────────┘
                │   Shadow      │    ┌─────────────┐
                │   Traffic     │───▶│ New Service │ (무시)
                └───────────────┘    └─────────────┘
```

**장점**:
- 실제 프로덕션 트래픽으로 테스트
- 사용자에게 영향 없음
- 성능/안정성 검증

### 6.4 모니터링 지표

| 지표 | 기준 | 롤백 조건 |
|------|------|----------|
| 에러율 | < 0.1% | > 1% |
| 응답 시간 (p99) | < 500ms | > 1000ms |
| 처리량 | 기존과 동등 | -20% |
| CPU/Memory | 정상 범위 | 급격한 증가 |

---

## 7. 롤백 전략

### 7.1 롤백 시나리오

| 시나리오 | 롤백 방법 |
|----------|----------|
| 트래픽 전환 실패 | 라우팅 규칙 복구 |
| 데이터 불일치 | 동기화 재실행 |
| 성능 저하 | Canary 비율 축소 |
| 기능 오류 | Feature Toggle OFF |

### 7.2 롤백 체크리스트

| 항목 | 확인 |
|------|------|
| 롤백 절차 문서화 | □ |
| 롤백 스크립트 준비 | □ |
| 롤백 테스트 완료 | □ |
| 데이터 복구 방안 | □ |
| 비상 연락망 | □ |

### 7.3 데이터 롤백

**Forward-only 원칙**:
- 데이터 롤백은 최대한 피함
- 애플리케이션 레벨에서 보상 트랜잭션 처리
- 필요시 이전 DB 스냅샷 활용

---

## 8. 마이그레이션 체크리스트

### 8.1 준비 단계

| 항목 | 확인 |
|------|------|
| 도메인 분석 완료 | □ |
| 서비스 경계 정의 | □ |
| 마이그레이션 로드맵 수립 | □ |
| 팀 역량 평가 | □ |
| 인프라 준비 | □ |
| 모니터링 구축 | □ |

### 8.2 실행 단계

| 항목 | 확인 |
|------|------|
| API Gateway/Proxy 구성 | □ |
| 서비스 코드 분리 | □ |
| 데이터베이스 분리 | □ |
| 데이터 동기화 설정 | □ |
| 데이터 일관성 검증 | □ |
| 통합 테스트 완료 | □ |

### 8.3 전환 단계

| 항목 | 확인 |
|------|------|
| Canary 배포 준비 | □ |
| 모니터링 대시보드 | □ |
| 롤백 절차 확인 | □ |
| 비상 대응 계획 | □ |
| 트래픽 점진적 전환 | □ |
| 최종 검증 완료 | □ |

### 8.4 완료 단계

| 항목 | 확인 |
|------|------|
| 구 시스템 트래픽 0% | □ |
| 데이터 동기화 중단 | □ |
| 구 시스템 비활성화 | □ |
| 문서 업데이트 | □ |
| 회고 및 개선점 정리 | □ |

---

## 9. 마이그레이션 사례

### 9.1 단계별 예시 - 이커머스

**Phase 1 - 기반 구축**:
- API Gateway 도입
- 로깅/모니터링 구축
- CI/CD 파이프라인 정비

**Phase 2 - 주변 서비스 분리**:
- 인증 서비스 (OAuth, JWT)
- 알림 서비스 (Email, SMS)
- 파일 업로드 서비스

**Phase 3 - 핵심 서비스 분리**:
- 사용자 서비스
- 상품 서비스
- 재고 서비스

**Phase 4 - 트랜잭션 서비스 분리**:
- 주문 서비스
- 결제 서비스
- 배송 서비스

### 9.2 타임라인 예시

```
Month 1-2: 평가 및 계획
  └─ 도메인 분석, 로드맵 수립

Month 3-4: 기반 구축
  └─ API Gateway, 모니터링

Month 5-8: 주변 서비스 분리
  └─ 인증, 알림, 파일

Month 9-14: 핵심 서비스 분리
  └─ 사용자, 상품, 재고

Month 15-20: 트랜잭션 서비스 분리
  └─ 주문, 결제, 배송

Month 21+: 최적화 및 고도화
  └─ 성능 튜닝, 추가 분리
```

---

## 10. 일반적인 실패 원인

### 10.1 기술적 실패

| 원인 | 예방 방안 |
|------|----------|
| 빅뱅 전환 시도 | 점진적 전환 (Strangler) |
| 데이터 불일치 | 충분한 검증 기간 |
| 성능 저하 | 사전 부하 테스트 |
| 롤백 불가 | 롤백 계획 및 테스트 |

### 10.2 조직적 실패

| 원인 | 예방 방안 |
|------|----------|
| 경영진 지원 부족 | 비즈니스 가치 명확화 |
| 팀 역량 부족 | 교육 및 외부 지원 |
| 일정 압박 | 현실적 로드맵 |
| 커뮤니케이션 부재 | 정기적 공유 |

---

## 11. 참고 자료

### 11.1 핵심 용어

| 용어 | 설명 |
|------|------|
| Strangler Fig | 점진적 시스템 대체 패턴 |
| Canary Release | 점진적 트래픽 전환 배포 |
| Blue-Green | 두 환경 간 즉시 전환 |
| Feature Toggle | 기능별 On/Off 제어 |
| CDC | Change Data Capture |
| Shadow Traffic | 복제 트래픽 테스트 |

### 11.2 주요 도구

| 영역 | 도구 |
|------|------|
| API Gateway | Kong, Nginx, Envoy |
| 데이터 동기화 | Debezium, AWS DMS |
| Feature Toggle | LaunchDarkly, Unleash |
| 모니터링 | Prometheus, Grafana |
| 분산 추적 | Jaeger, Zipkin |

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| 1.0 | 2025-01-07 | 최초 작성 |
