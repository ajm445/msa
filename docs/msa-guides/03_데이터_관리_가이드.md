# MSA 데이터 관리 가이드

## 문서 정보

| 항목 | 내용 |
|------|------|
| 문서명 | MSA 데이터 관리 가이드 |
| 버전 | 1.0 |
| 목적 | 마이크로서비스 데이터 관리 전략 및 패턴 제공 |

---

## 1. 데이터 관리 원칙

### 1.1 MSA 데이터 관리의 핵심

**원칙**: 각 서비스는 자신의 데이터를 소유하고 관리한다.

| 항목 | 모놀리식 | MSA |
|------|----------|-----|
| 데이터베이스 | 공유 DB | 서비스별 독립 DB |
| 데이터 접근 | 직접 접근 | API 통한 접근 |
| 트랜잭션 | ACID | 분산 트랜잭션/Saga |
| 일관성 | 강한 일관성 | 최종 일관성 |
| 조인 | SQL JOIN | API Composition |

### 1.2 데이터 소유권 규칙

**규칙 1: 단일 소유자 원칙**
- 각 데이터는 하나의 서비스만 소유
- 소유 서비스만 해당 데이터를 생성/수정/삭제
- 다른 서비스는 API를 통해서만 접근

**규칙 2: 데이터 캡슐화**
- 데이터베이스 스키마는 서비스 내부 구현 상세
- 외부 서비스는 데이터 구조를 알 필요 없음
- API 계약만 공개

---

## 2. Database per Service 패턴

### 2.1 패턴 개요

각 마이크로서비스가 독립적인 데이터베이스를 소유하는 패턴이다.

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   주문      │    │   재고      │    │   배송      │
│  서비스     │    │  서비스     │    │  서비스     │
└──────┬──────┘    └──────┬──────┘    └──────┬──────┘
       │                  │                  │
       ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  Order DB   │    │ Inventory   │    │ Shipping    │
│ (PostgreSQL)│    │    DB       │    │    DB       │
│             │    │  (MongoDB)  │    │ (PostgreSQL)│
└─────────────┘    └─────────────┘    └─────────────┘
```

### 2.2 구현 방식

| 방식 | 설명 | 격리 수준 |
|------|------|----------|
| 별도 DB 인스턴스 | 서비스별 독립 DB 서버 | 높음 |
| 별도 스키마 | 같은 DB 서버, 다른 스키마 | 중간 |
| 별도 테이블 | 같은 스키마, 테이블 분리 | 낮음 |

**권장**: 별도 DB 인스턴스 또는 별도 스키마 사용

### 2.3 장점

- **독립적 확장**: 서비스별 DB 확장 가능
- **기술 다양성**: 서비스에 적합한 DB 선택 (Polyglot Persistence)
- **장애 격리**: 한 DB 장애가 다른 서비스에 영향 없음
- **독립적 배포**: 스키마 변경이 다른 서비스에 영향 없음

### 2.4 도전 과제

- 분산 트랜잭션 처리 복잡
- 데이터 조회 시 다중 서비스 호출 필요
- 데이터 중복 관리
- 데이터 일관성 유지

---

## 3. Polyglot Persistence

### 3.1 개념

**Polyglot Persistence**는 서비스의 요구사항에 맞는 다양한 데이터베이스를 혼용하는 전략이다.

### 3.2 데이터베이스 유형별 특성

| 유형 | 특성 | 적합한 사용 사례 |
|------|------|-----------------|
| **RDBMS** | ACID, 스키마, 관계 | 트랜잭션, 복잡한 쿼리 |
| **Document DB** | 스키마리스, JSON | 유연한 구조, 빠른 개발 |
| **Key-Value** | 단순 조회, 고성능 | 캐시, 세션 |
| **Graph DB** | 관계 중심 | 소셜 네트워크, 추천 |
| **Time-Series** | 시계열 데이터 최적화 | 로그, 모니터링 |
| **Search Engine** | 전문 검색 | 검색, 분석 |

### 3.3 서비스별 DB 선택 예시

| 서비스 | 추천 DB | 선택 이유 |
|--------|---------|----------|
| 사용자 | PostgreSQL | ACID, 관계 데이터 |
| 상품 카탈로그 | MongoDB | 유연한 속성, 빠른 조회 |
| 장바구니 | Redis | 세션 기반, 고성능 |
| 검색 | Elasticsearch | 전문 검색, 필터링 |
| 주문 | PostgreSQL | 트랜잭션 무결성 |
| 로그/이벤트 | Kafka + ClickHouse | 대용량 시계열 |
| 추천 | Neo4j | 그래프 관계 분석 |

---

## 4. 데이터 일관성 전략

### 4.1 CAP 정리

분산 시스템에서는 다음 세 가지를 동시에 만족할 수 없다:

| 속성 | 설명 |
|------|------|
| **C**onsistency | 모든 노드가 같은 데이터 |
| **A**vailability | 항상 응답 가능 |
| **P**artition Tolerance | 네트워크 분할에도 동작 |

**MSA에서의 선택**:
- 네트워크 분할은 불가피 (P 필수)
- 일관성(C)과 가용성(A) 중 선택 필요
- 대부분 **AP** 선택 + **최종 일관성**

### 4.2 강한 일관성 vs 최종 일관성

| 항목 | 강한 일관성 | 최종 일관성 |
|------|-----------|-----------|
| 데이터 상태 | 항상 일치 | 일정 시간 후 일치 |
| 응답 시간 | 느림 | 빠름 |
| 가용성 | 낮음 | 높음 |
| 구현 복잡도 | 높음 | 낮음 |
| 적합 사례 | 금융, 재고 | 소셜, 알림 |

### 4.3 최종 일관성 구현 패턴

**이벤트 기반 동기화**:
```
주문 서비스                재고 서비스
    │                          │
    │  OrderCreated 이벤트      │
    │─────────────────────────▶│
    │                          │ 재고 차감
    │                          │
    │  StockReserved 이벤트     │
    │◀─────────────────────────│
    │ 주문 확정                  │
```

**일관성 윈도우**:
- 이벤트 발행 → 소비까지의 시간
- 일반적으로 수 밀리초 ~ 수 초
- 비즈니스 요구사항에 따라 허용 범위 결정

---

## 5. 분산 트랜잭션 처리

### 5.1 2PC (Two-Phase Commit)

**2단계 커밋** 프로토콜은 분산 트랜잭션의 원자성을 보장한다.

```
Coordinator          Participant A       Participant B
     │                    │                    │
     │──── Prepare ──────▶│                    │
     │──── Prepare ───────┼───────────────────▶│
     │                    │                    │
     │◀─── Ready ─────────│                    │
     │◀─── Ready ─────────┼────────────────────│
     │                    │                    │
     │──── Commit ───────▶│                    │
     │──── Commit ────────┼───────────────────▶│
```

**MSA에서 2PC의 문제점**:
- 성능 저하 (Lock 대기)
- 단일 장애점 (Coordinator)
- 확장성 제한
- 서비스 간 강한 결합

**결론**: MSA에서는 2PC 대신 **Saga 패턴** 권장

### 5.2 Saga 패턴

**Saga**는 분산 트랜잭션을 일련의 로컬 트랜잭션으로 분해하는 패턴이다.

각 로컬 트랜잭션은:
- 데이터 업데이트
- 다음 트랜잭션을 트리거하는 이벤트 발행
- 실패 시 보상 트랜잭션 실행

### 5.3 Saga - Choreography 방식

서비스들이 이벤트를 통해 자율적으로 협력한다.

```
주문 서비스    재고 서비스    결제 서비스    배송 서비스
     │              │              │              │
     │ OrderCreated │              │              │
     │─────────────▶│              │              │
     │              │ StockReserved│              │
     │              │─────────────▶│              │
     │              │              │PaymentCompleted
     │              │              │─────────────▶│
     │              │              │              │ ShippingScheduled
     │◀─────────────┼──────────────┼──────────────│
```

**장점**:
- 느슨한 결합
- 단일 장애점 없음
- 단순한 구현 (소규모)

**단점**:
- 흐름 파악 어려움
- 순환 의존성 위험
- 복잡한 Saga에 부적합

### 5.4 Saga - Orchestration 방식

중앙 조정자(Orchestrator)가 Saga 흐름을 제어한다.

```
         Orchestrator
              │
    ┌─────────┼─────────┐
    │         │         │
    ▼         ▼         ▼
┌───────┐ ┌───────┐ ┌───────┐
│ 주문  │ │ 재고  │ │ 결제  │
│서비스 │ │서비스 │ │서비스 │
└───────┘ └───────┘ └───────┘
```

**장점**:
- 흐름이 명확
- 복잡한 Saga 관리 용이
- 테스트 용이

**단점**:
- Orchestrator가 단일 장애점
- 중앙 집중화로 결합도 증가

### 5.5 보상 트랜잭션

Saga 실패 시 이전 작업을 취소하는 보상(Compensation) 트랜잭션이 필요하다.

| 정방향 트랜잭션 | 보상 트랜잭션 |
|---------------|--------------|
| 주문 생성 | 주문 취소 |
| 재고 차감 | 재고 복구 |
| 결제 승인 | 결제 취소 |
| 배송 예약 | 배송 취소 |

**보상 트랜잭션 설계 원칙**:
- 멱등성 보장
- 비즈니스 롤백 (기술적 롤백 아님)
- 실패 재시도 가능

---

## 6. 데이터 조회 패턴

### 6.1 API Composition

여러 서비스의 데이터를 조합하여 응답하는 패턴이다.

```
        Client
           │
           ▼
    ┌─────────────┐
    │ API Gateway │
    │  (Composer) │
    └──────┬──────┘
           │
    ┌──────┼──────┐
    │      │      │
    ▼      ▼      ▼
┌──────┐┌──────┐┌──────┐
│사용자││주문  ││상품  │
│서비스││서비스││서비스│
└──────┘└──────┘└──────┘
```

**구현 예시**:
```javascript
async function getOrderDetails(orderId) {
  // 병렬로 여러 서비스 호출
  const [order, user, products] = await Promise.all([
    orderService.getOrder(orderId),
    userService.getUser(order.userId),
    productService.getProducts(order.productIds)
  ]);

  // 데이터 조합
  return {
    ...order,
    user: {
      name: user.name,
      email: user.email
    },
    items: products.map(p => ({
      name: p.name,
      price: p.price
    }))
  };
}
```

**장점**:
- 구현 단순
- 실시간 데이터

**단점**:
- 네트워크 호출 증가
- 응답 시간 증가
- 가용성 감소 (의존 서비스 장애 시)

### 6.2 CQRS (Command Query Responsibility Segregation)

명령(쓰기)과 조회(읽기) 모델을 분리하는 패턴이다.

```
┌─────────────────────────────────────────────────────┐
│                                                     │
│   ┌─────────┐         ┌─────────┐                  │
│   │ Command │         │  Query  │                  │
│   │   API   │         │   API   │                  │
│   └────┬────┘         └────┬────┘                  │
│        │                   │                        │
│        ▼                   ▼                        │
│   ┌─────────┐         ┌─────────┐                  │
│   │  Write  │  Event  │  Read   │                  │
│   │  Model  │────────▶│  Model  │                  │
│   └────┬────┘         └────┬────┘                  │
│        │                   │                        │
│        ▼                   ▼                        │
│   ┌─────────┐         ┌─────────┐                  │
│   │Write DB │         │ Read DB │                  │
│   │(Primary)│         │(Replica)│                  │
│   └─────────┘         └─────────┘                  │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**장점**:
- 읽기/쓰기 독립적 최적화
- 조회 성능 향상
- 복잡한 조회 쿼리 지원

**단점**:
- 시스템 복잡도 증가
- 데이터 동기화 지연
- 최종 일관성 수용 필요

### 6.3 Materialized View

조회에 최적화된 사전 계산 뷰를 생성하는 패턴이다.

**사용 사례**:
- 대시보드 집계 데이터
- 검색 인덱스
- 리포트 데이터

**구현 방법**:
1. 이벤트 구독
2. 읽기 전용 DB에 뷰 업데이트
3. 조회 시 사전 계산된 데이터 반환

---

## 7. 데이터 복제 및 동기화

### 7.1 데이터 복제 패턴

| 패턴 | 설명 | 사용 사례 |
|------|------|----------|
| **이벤트 기반** | 변경 이벤트 발행/구독 | 일반적인 서비스 간 동기화 |
| **CDC** | DB 변경 로그 캡처 | 레거시 연동 |
| **API 폴링** | 주기적 API 호출 | 외부 시스템 연동 |
| **듀얼 라이트** | 동시에 여러 DB 쓰기 | 권장하지 않음 |

### 7.2 CDC (Change Data Capture)

데이터베이스 변경 로그를 캡처하여 이벤트로 발행한다.

```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│  App    │───▶│   DB    │───▶│Debezium │───▶│  Kafka  │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
                    │                              │
               WAL/Binlog                    ┌─────▼─────┐
                                             │ Consumer  │
                                             │ Services  │
                                             └───────────┘
```

**주요 도구**:
- Debezium (Kafka Connect)
- AWS DMS
- Oracle GoldenGate

**장점**:
- 애플리케이션 코드 변경 불필요
- 모든 변경 캡처
- 순서 보장

**단점**:
- DB 의존적
- 인프라 복잡도 증가

### 7.3 데이터 중복 관리

**허용되는 데이터 중복**:
- 조회 성능을 위한 비정규화
- 캐시 데이터
- CQRS 읽기 모델

**관리 원칙**:
- 원본 데이터 소유자 명확히
- 동기화 메커니즘 구현
- 불일치 감지 및 복구 절차

---

## 8. 데이터 관리 체크리스트

### 8.1 설계 시 확인사항

| 항목 | 질문 | 확인 |
|------|------|------|
| 소유권 | 각 데이터의 소유 서비스가 명확한가? | □ |
| 접근 방식 | 다른 서비스는 API로만 접근하는가? | □ |
| DB 선택 | 서비스 요구사항에 맞는 DB인가? | □ |
| 일관성 | 일관성 요구사항이 정의되었는가? | □ |
| 트랜잭션 | 분산 트랜잭션 처리 방안이 있는가? | □ |

### 8.2 구현 시 확인사항

| 항목 | 질문 | 확인 |
|------|------|------|
| Saga | 보상 트랜잭션이 구현되었는가? | □ |
| 멱등성 | 중복 처리에 안전한가? | □ |
| 동기화 | 데이터 동기화 방식이 정의되었는가? | □ |
| 복구 | 불일치 시 복구 절차가 있는가? | □ |
| 모니터링 | 데이터 정합성 모니터링이 있는가? | □ |

---

## 9. 참고 자료

### 9.1 핵심 용어

| 용어 | 설명 |
|------|------|
| Database per Service | 서비스별 독립 DB 패턴 |
| Polyglot Persistence | 다양한 DB 기술 혼용 |
| Saga | 분산 트랜잭션을 로컬 트랜잭션으로 분해하는 패턴 |
| CQRS | 명령과 조회 책임 분리 |
| CDC | Change Data Capture, DB 변경 캡처 |
| Eventual Consistency | 최종 일관성 |
| Compensation | 보상 트랜잭션 |

### 9.2 주요 도구

| 영역 | 도구 |
|------|------|
| RDBMS | PostgreSQL, MySQL |
| Document | MongoDB, DynamoDB |
| Key-Value | Redis, Memcached |
| Search | Elasticsearch |
| CDC | Debezium, AWS DMS |
| Message | Kafka, RabbitMQ |

---

## 변경 이력

| 버전 | 날짜 | 변경 내용 |
|------|------|----------|
| 1.0 | 2025-01-07 | 최초 작성 |
